 1. Nuevas Tablas

  -- =============================================
  -- COTIZACIONES Y VENTAS POR CATÁLOGO
  -- =============================================

  -- Tabla de cotizaciones
  CREATE TABLE public.cotizaciones (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    numero_cotizacion text NOT NULL UNIQUE,
    cliente_id uuid NOT NULL,
    usuario_id uuid NOT NULL,
    tipo text NOT NULL CHECK (tipo IN ('cotizacion', 'catalogo')),
    estado text NOT NULL DEFAULT 'borrador' CHECK (estado IN ('borrador', 'enviada', 'aprobada',
  'rechazada', 'vencida', 'convertida')),
    fecha_emision date NOT NULL DEFAULT current_date,
    fecha_vencimiento date NOT NULL,
    subtotal numeric(12,2) NOT NULL DEFAULT 0,
    descuento numeric(5,2) DEFAULT 0,
    impuestos numeric(12,2) DEFAULT 0,
    total numeric(12,2) NOT NULL DEFAULT 0,
    observaciones text,
    condiciones_pago text,
    tiempo_entrega text,
    validez_oferta integer DEFAULT 30, -- días
    venta_id uuid, -- Si se convierte en venta
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT cotizaciones_pkey PRIMARY KEY (id),
    CONSTRAINT cotizaciones_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.clientes(id),
    CONSTRAINT cotizaciones_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.profiles(id),
    CONSTRAINT cotizaciones_venta_id_fkey FOREIGN KEY (venta_id) REFERENCES public.ventas(id)
  );

  -- Detalles de cotizaciones
  CREATE TABLE public.cotizacion_detalle (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    cotizacion_id uuid NOT NULL,
    producto_id uuid,
    descripcion text NOT NULL, -- Para productos de catálogo sin stock
    cantidad integer NOT NULL DEFAULT 1,
    precio_unitario numeric(12,2) NOT NULL,
    descuento_item numeric(5,2) DEFAULT 0,
    subtotal numeric(12,2) NOT NULL,
    observaciones text,
    tiempo_entrega text,
    es_catalogo boolean DEFAULT false, -- Si es producto de catálogo
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT cotizacion_detalle_pkey PRIMARY KEY (id),
    CONSTRAINT cotizacion_detalle_cotizacion_id_fkey FOREIGN KEY (cotizacion_id) REFERENCES
  public.cotizaciones(id) ON DELETE CASCADE,
    CONSTRAINT cotizacion_detalle_producto_id_fkey FOREIGN KEY (producto_id) REFERENCES public.productos(id)     
  );

  -- =============================================
  -- HISTORIAL DE SERVICIOS
  -- =============================================

  -- Tabla de servicios realizados
  CREATE TABLE public.servicios (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    cliente_id uuid NOT NULL,
    vehiculo_id uuid,
    turno_id uuid,
    venta_id uuid,
    tipo_servicio text NOT NULL, -- 'mantenimiento', 'reparacion', 'cambio_neumaticos', etc.
    descripcion text NOT NULL,
    observaciones text,
    tecnico_responsable text,
    fecha_inicio timestamp without time zone NOT NULL,
    fecha_fin timestamp without time zone,
    estado text NOT NULL DEFAULT 'programado' CHECK (estado IN ('programado', 'en_proceso', 'completado',        
  'cancelado')),
    costo_mano_obra numeric(12,2) DEFAULT 0,
    tiempo_estimado interval, -- tiempo estimado en formato interval
    tiempo_real interval, -- tiempo real utilizado
    kilometraje integer,
    proximo_servicio_km integer,
    proximo_servicio_fecha date,
    garantia_dias integer DEFAULT 0,
    calificacion integer CHECK (calificacion >= 1 AND calificacion <= 5),
    comentario_cliente text,
    imagenes_antes jsonb, -- URLs de imágenes antes del servicio
    imagenes_despues jsonb, -- URLs de imágenes después del servicio
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT servicios_pkey PRIMARY KEY (id),
    CONSTRAINT servicios_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.clientes(id),
    CONSTRAINT servicios_vehiculo_id_fkey FOREIGN KEY (vehiculo_id) REFERENCES public.vehiculos(id),
    CONSTRAINT servicios_turno_id_fkey FOREIGN KEY (turno_id) REFERENCES public.turnos(id),
    CONSTRAINT servicios_venta_id_fkey FOREIGN KEY (venta_id) REFERENCES public.ventas(id)
  );

  -- Productos/repuestos utilizados en el servicio
  CREATE TABLE public.servicio_productos (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    servicio_id uuid NOT NULL,
    producto_id uuid NOT NULL,
    cantidad integer NOT NULL DEFAULT 1,
    precio_unitario numeric(12,2) NOT NULL,
    subtotal numeric(12,2) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT servicio_productos_pkey PRIMARY KEY (id),
    CONSTRAINT servicio_productos_servicio_id_fkey FOREIGN KEY (servicio_id) REFERENCES public.servicios(id)     
   ON DELETE CASCADE,
    CONSTRAINT servicio_productos_producto_id_fkey FOREIGN KEY (producto_id) REFERENCES public.productos(id)     
  );

  -- =============================================
  -- SEGMENTACIÓN DE CLIENTES
  -- =============================================

  -- Segmentos de clientes
  CREATE TABLE public.segmentos_cliente (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    nombre text NOT NULL UNIQUE,
    descripcion text,
    criterios jsonb NOT NULL, -- Criterios de segmentación en JSON
    color text DEFAULT '#3B82F6',
    activo boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT segmentos_cliente_pkey PRIMARY KEY (id)
  );

  -- Relación muchos a muchos entre clientes y segmentos
  CREATE TABLE public.cliente_segmentos (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    cliente_id uuid NOT NULL,
    segmento_id uuid NOT NULL,
    fecha_asignacion timestamp without time zone DEFAULT now(),
    automatico boolean DEFAULT true, -- Si fue asignado automáticamente
    CONSTRAINT cliente_segmentos_pkey PRIMARY KEY (id),
    CONSTRAINT cliente_segmentos_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.clientes(id) ON      
  DELETE CASCADE,
    CONSTRAINT cliente_segmentos_segmento_id_fkey FOREIGN KEY (segmento_id) REFERENCES
  public.segmentos_cliente(id) ON DELETE CASCADE,
    CONSTRAINT cliente_segmentos_unique UNIQUE (cliente_id, segmento_id)
  );

  -- =============================================
  -- CUENTAS CORRIENTES
  -- =============================================

  -- Movimientos de cuenta corriente
  CREATE TABLE public.cuenta_corriente (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    cliente_id uuid NOT NULL,
    tipo_movimiento text NOT NULL CHECK (tipo_movimiento IN ('debito', 'credito')),
    concepto text NOT NULL, -- 'venta', 'pago', 'ajuste', 'interes', 'descuento'
    descripcion text NOT NULL,
    monto numeric(12,2) NOT NULL,
    saldo_anterior numeric(12,2) NOT NULL DEFAULT 0,
    saldo_nuevo numeric(12,2) NOT NULL DEFAULT 0,
    fecha_movimiento timestamp without time zone NOT NULL DEFAULT now(),
    fecha_vencimiento date, -- Para créditos con vencimiento
    venta_id uuid, -- Si está relacionado con una venta
    pago_id uuid, -- Si está relacionado con un pago
    usuario_id uuid NOT NULL,
    observaciones text,
    anulado boolean DEFAULT false,
    fecha_anulacion timestamp without time zone,
    motivo_anulacion text,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT cuenta_corriente_pkey PRIMARY KEY (id),
    CONSTRAINT cuenta_corriente_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.clientes(id),
    CONSTRAINT cuenta_corriente_venta_id_fkey FOREIGN KEY (venta_id) REFERENCES public.ventas(id),
    CONSTRAINT cuenta_corriente_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.profiles(id)
  );

  -- Tabla de pagos
  CREATE TABLE public.pagos (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    cliente_id uuid NOT NULL,
    numero_recibo text UNIQUE,
    monto_total numeric(12,2) NOT NULL,
    metodo_pago text NOT NULL CHECK (metodo_pago IN ('efectivo', 'transferencia', 'cheque', 'tarjeta')),
    fecha_pago date NOT NULL DEFAULT current_date,
    observaciones text,
    usuario_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT pagos_pkey PRIMARY KEY (id),
    CONSTRAINT pagos_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.clientes(id),
    CONSTRAINT pagos_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.profiles(id)
  );

  -- Detalle de qué ventas se están pagando
  CREATE TABLE public.pago_aplicaciones (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    pago_id uuid NOT NULL,
    venta_id uuid NOT NULL,
    monto_aplicado numeric(12,2) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT pago_aplicaciones_pkey PRIMARY KEY (id),
    CONSTRAINT pago_aplicaciones_pago_id_fkey FOREIGN KEY (pago_id) REFERENCES public.pagos(id) ON DELETE        
  CASCADE,
    CONSTRAINT pago_aplicaciones_venta_id_fkey FOREIGN KEY (venta_id) REFERENCES public.ventas(id)
  );

  -- =============================================
  -- FLUJO DE CAJA
  -- =============================================

  -- Conceptos de flujo de caja
  CREATE TABLE public.conceptos_flujo (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    nombre text NOT NULL UNIQUE,
    tipo text NOT NULL CHECK (tipo IN ('ingreso', 'egreso')),
    categoria text NOT NULL, -- 'ventas', 'compras', 'gastos_operativos', 'impuestos', etc.
    activo boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT conceptos_flujo_pkey PRIMARY KEY (id)
  );

  -- Movimientos de flujo de caja
  CREATE TABLE public.flujo_caja (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    concepto_id uuid NOT NULL,
    tipo text NOT NULL CHECK (tipo IN ('real', 'proyectado')),
    fecha_movimiento date NOT NULL,
    monto numeric(12,2) NOT NULL,
    descripcion text NOT NULL,
    observaciones text,
    venta_id uuid, -- Si proviene de una venta
    compra_id uuid, -- Si proviene de una compra
    pago_id uuid, -- Si proviene de un pago
    usuario_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    CONSTRAINT flujo_caja_pkey PRIMARY KEY (id),
    CONSTRAINT flujo_caja_concepto_id_fkey FOREIGN KEY (concepto_id) REFERENCES public.conceptos_flujo(id),      
    CONSTRAINT flujo_caja_venta_id_fkey FOREIGN KEY (venta_id) REFERENCES public.ventas(id),
    CONSTRAINT flujo_caja_compra_id_fkey FOREIGN KEY (compra_id) REFERENCES public.compras(id),
    CONSTRAINT flujo_caja_pago_id_fkey FOREIGN KEY (pago_id) REFERENCES public.pagos(id),
    CONSTRAINT flujo_caja_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.profiles(id)
  );

  2. Modificaciones a Tablas Existentes

  -- =============================================
  -- MEJORAS A TABLAS EXISTENTES
  -- =============================================

  -- Agregar campos a clientes para segmentación
  ALTER TABLE public.clientes ADD COLUMN IF NOT EXISTS
    fecha_nacimiento date,
    genero text CHECK (genero IN ('masculino', 'femenino', 'otro')),
    profesion text,
    observaciones text,
    activo boolean DEFAULT true,
    fecha_primera_compra timestamp without time zone,
    fecha_ultima_compra timestamp without time zone,
    total_compras numeric(12,2) DEFAULT 0,
    frecuencia_compra numeric(5,2) DEFAULT 0, -- compras por mes promedio
    ticket_promedio numeric(12,2) DEFAULT 0,
    categoria_cliente text DEFAULT 'regular' CHECK (categoria_cliente IN ('nuevo', 'regular', 'frecuente',       
  'vip', 'inactivo')),
    descuento_especial numeric(5,2) DEFAULT 0,
    limite_credito numeric(12,2) DEFAULT 0,
    dias_credito integer DEFAULT 0,
    updated_at timestamp without time zone DEFAULT now();

  -- Agregar campos a productos para catálogo
  ALTER TABLE public.productos ADD COLUMN IF NOT EXISTS
    codigo_barras text UNIQUE,
    categoria text,
    subcategoria text,
    descripcion_larga text,
    especificaciones jsonb,
    imagenes jsonb, -- Array de URLs de imágenes
    es_catalogo boolean DEFAULT false, -- Si se vende sin stock
    tiempo_entrega_dias integer DEFAULT 0,
    peso numeric(8,3), -- en kg
    dimensiones jsonb, -- {largo, ancho, alto}
    activo boolean DEFAULT true,
    destacado boolean DEFAULT false,
    orden_catalogo integer DEFAULT 0,
    tags text[], -- Para búsquedas
    updated_at timestamp without time zone DEFAULT now();

  -- Agregar campos a ventas para mejorar reportes
  ALTER TABLE public.ventas ADD COLUMN IF NOT EXISTS
    numero_factura text UNIQUE,
    tipo_comprobante text DEFAULT 'ticket' CHECK (tipo_comprobante IN ('ticket', 'factura_a', 'factura_b',       
  'factura_c')),
    condicion_pago text DEFAULT 'contado' CHECK (condicion_pago IN ('contado', 'credito')),
    fecha_vencimiento date,
    observaciones text,
    vendedor_id uuid REFERENCES public.profiles(id),
    comision_vendedor numeric(5,2) DEFAULT 0,
    costo_total numeric(12,2) DEFAULT 0, -- Para calcular rentabilidad
    margen_bruto numeric(12,2) DEFAULT 0,
    porcentaje_margen numeric(5,2) DEFAULT 0,
    canal_venta text DEFAULT 'mostrador' CHECK (canal_venta IN ('mostrador', 'telefono', 'whatsapp',
  'online')),
    origen_cliente text DEFAULT 'directo' CHECK (origen_cliente IN ('directo', 'referido', 'publicidad',
  'web')),
    updated_at timestamp without time zone DEFAULT now();

  -- Agregar campos a vehiculos para historial
  ALTER TABLE public.vehiculos ADD COLUMN IF NOT EXISTS
    numero_motor text,
    numero_chasis text,
    combustible text CHECK (combustible IN ('nafta', 'diesel', 'gnc', 'electrico', 'hibrido')),
    cilindrada text,
    color text,
    kilometraje_actual integer DEFAULT 0,
    fecha_ultima_revision date,
    observaciones text,
    activo boolean DEFAULT true,
    updated_at timestamp without time zone DEFAULT now();

  -- Mejorar tabla de proveedores
  ALTER TABLE public.proveedores ADD COLUMN IF NOT EXISTS
    direccion text,
    ciudad text,
    provincia text,
    codigo_postal text,
    contacto_principal text,
    cargo_contacto text,
    telefono_alternativo text,
    sitio_web text,
    observaciones text,
    activo boolean DEFAULT true,
    calificacion integer CHECK (calificacion >= 1 AND calificacion <= 5),
    condiciones_pago text,
    tiempo_entrega_promedio integer DEFAULT 0, -- días
    margen_ganancia numeric(5,2) DEFAULT 0.30, -- 30% por defecto
    updated_at timestamp without time zone DEFAULT now();

  3. Índices para Performance

  -- =============================================
  -- ÍNDICES PARA OPTIMIZAR CONSULTAS
  -- =============================================

  -- Índices para cotizaciones
  CREATE INDEX idx_cotizaciones_cliente_id ON public.cotizaciones(cliente_id);
  CREATE INDEX idx_cotizaciones_estado ON public.cotizaciones(estado);
  CREATE INDEX idx_cotizaciones_fecha_emision ON public.cotizaciones(fecha_emision);
  CREATE INDEX idx_cotizaciones_tipo ON public.cotizaciones(tipo);

  -- Índices para servicios
  CREATE INDEX idx_servicios_cliente_id ON public.servicios(cliente_id);
  CREATE INDEX idx_servicios_vehiculo_id ON public.servicios(vehiculo_id);
  CREATE INDEX idx_servicios_fecha_inicio ON public.servicios(fecha_inicio);
  CREATE INDEX idx_servicios_estado ON public.servicios(estado);
  CREATE INDEX idx_servicios_tipo_servicio ON public.servicios(tipo_servicio);

  -- Índices para cuenta corriente
  CREATE INDEX idx_cuenta_corriente_cliente_id ON public.cuenta_corriente(cliente_id);
  CREATE INDEX idx_cuenta_corriente_fecha_movimiento ON public.cuenta_corriente(fecha_movimiento);
  CREATE INDEX idx_cuenta_corriente_tipo_movimiento ON public.cuenta_corriente(tipo_movimiento);

  -- Índices para flujo de caja
  CREATE INDEX idx_flujo_caja_fecha_movimiento ON public.flujo_caja(fecha_movimiento);
  CREATE INDEX idx_flujo_caja_concepto_id ON public.flujo_caja(concepto_id);
  CREATE INDEX idx_flujo_caja_tipo ON public.flujo_caja(tipo);

  -- Índices para segmentación
  CREATE INDEX idx_cliente_segmentos_cliente_id ON public.cliente_segmentos(cliente_id);
  CREATE INDEX idx_cliente_segmentos_segmento_id ON public.cliente_segmentos(segmento_id);

  -- Índices mejorados para reportes
  CREATE INDEX idx_ventas_fecha_vendedor ON public.ventas(created_at, vendedor_id);
  CREATE INDEX idx_ventas_cliente_fecha ON public.ventas(cliente_id, created_at);
  CREATE INDEX idx_venta_detalle_producto_fecha ON public.venta_detalle(producto_id, created_at);

  4. Funciones y Triggers

  -- =============================================
  -- FUNCIONES Y TRIGGERS AUTOMÁTICOS
  -- =============================================

  -- Función para actualizar timestamp
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
      NEW.updated_at = now();
      RETURN NEW;
  END;
  $$ language 'plpgsql';

  -- Triggers para updated_at
  CREATE TRIGGER update_clientes_updated_at BEFORE UPDATE ON public.clientes FOR EACH ROW EXECUTE FUNCTION       
  update_updated_at_column();
  CREATE TRIGGER update_productos_updated_at BEFORE UPDATE ON public.productos FOR EACH ROW EXECUTE FUNCTION     
   update_updated_at_column();
  CREATE TRIGGER update_ventas_updated_at BEFORE UPDATE ON public.ventas FOR EACH ROW EXECUTE FUNCTION
  update_updated_at_column();
  CREATE TRIGGER update_cotizaciones_updated_at BEFORE UPDATE ON public.cotizaciones FOR EACH ROW EXECUTE        
  FUNCTION update_updated_at_column();
  CREATE TRIGGER update_servicios_updated_at BEFORE UPDATE ON public.servicios FOR EACH ROW EXECUTE FUNCTION     
   update_updated_at_column();

  -- Función para calcular saldo de cuenta corriente
  CREATE OR REPLACE FUNCTION calcular_saldo_cuenta_corriente()
  RETURNS TRIGGER AS $$
  BEGIN
      -- Obtener saldo anterior
      SELECT COALESCE(saldo_nuevo, 0) INTO NEW.saldo_anterior
      FROM public.cuenta_corriente
      WHERE cliente_id = NEW.cliente_id
      ORDER BY fecha_movimiento DESC, created_at DESC
      LIMIT 1;

      -- Calcular nuevo saldo
      IF NEW.tipo_movimiento = 'debito' THEN
          NEW.saldo_nuevo = NEW.saldo_anterior + NEW.monto;
      ELSE
          NEW.saldo_nuevo = NEW.saldo_anterior - NEW.monto;
      END IF;

      RETURN NEW;
  END;
  $$ language 'plpgsql';

  CREATE TRIGGER trigger_calcular_saldo BEFORE INSERT ON public.cuenta_corriente FOR EACH ROW EXECUTE
  FUNCTION calcular_saldo_cuenta_corriente();

  -- Función para actualizar estadísticas de cliente
  CREATE OR REPLACE FUNCTION actualizar_estadisticas_cliente()
  RETURNS TRIGGER AS $$
  BEGIN
      UPDATE public.clientes SET
          fecha_ultima_compra = NEW.created_at,
          total_compras = (
              SELECT COALESCE(SUM(total), 0)
              FROM public.ventas
              WHERE cliente_id = NEW.cliente_id
          ),
          ticket_promedio = (
              SELECT COALESCE(AVG(total), 0)
              FROM public.ventas
              WHERE cliente_id = NEW.cliente_id
          )
      WHERE id = NEW.cliente_id;

      -- Actualizar fecha_primera_compra si es null
      UPDATE public.clientes SET
          fecha_primera_compra = (
              SELECT MIN(created_at)
              FROM public.ventas
              WHERE cliente_id = NEW.cliente_id
          )
      WHERE id = NEW.cliente_id AND fecha_primera_compra IS NULL;

      RETURN NEW;
  END;
  $$ language 'plpgsql';

  CREATE TRIGGER trigger_actualizar_estadisticas_cliente AFTER INSERT ON public.ventas FOR EACH ROW EXECUTE      
  FUNCTION actualizar_estadisticas_cliente();

  5. Vistas para Reportes

  -- =============================================
  -- VISTAS PARA FACILITAR REPORTES
  -- =============================================

  -- Vista de rentabilidad por producto
  CREATE OR REPLACE VIEW vista_rentabilidad_productos AS
  SELECT
      p.id,
      p.nombre,
      p.tipo,
      p.marca,
      p.costo,
      p.precio_calculado,
      COALESCE(SUM(vd.cantidad), 0) as cantidad_vendida,
      COALESCE(SUM(vd.subtotal), 0) as ingresos_totales,
      COALESCE(SUM(vd.cantidad * p.costo), 0) as costo_total,
      COALESCE(SUM(vd.subtotal) - SUM(vd.cantidad * p.costo), 0) as ganancia_bruta,
      CASE
          WHEN SUM(vd.subtotal) > 0 THEN
              ROUND(((SUM(vd.subtotal) - SUM(vd.cantidad * p.costo)) / SUM(vd.subtotal) * 100)::numeric, 2)      
          ELSE 0
      END as margen_porcentaje
  FROM public.productos p
  LEFT JOIN public.venta_detalle vd ON p.id = vd.producto_id
  LEFT JOIN public.ventas v ON vd.venta_id = v.id
  GROUP BY p.id, p.nombre, p.tipo, p.marca, p.costo, p.precio_calculado;

  -- Vista de análisis RFM de clientes
  CREATE OR REPLACE VIEW vista_analisis_rfm AS
  WITH cliente_stats AS (
      SELECT
          c.id,
          c.nombre,
          COALESCE(MAX(v.created_at), c.created_at) as ultima_compra,
          EXTRACT(DAYS FROM (CURRENT_DATE - COALESCE(MAX(v.created_at), c.created_at)::date)) as recency,        
          COUNT(v.id) as frequency,
          COALESCE(SUM(v.total), 0) as monetary
      FROM public.clientes c
      LEFT JOIN public.ventas v ON c.id = v.cliente_id
      GROUP BY c.id, c.nombre, c.created_at
  ),
  rfm_scores AS (
      SELECT *,
          NTILE(5) OVER (ORDER BY recency DESC) as r_score,
          NTILE(5) OVER (ORDER BY frequency ASC) as f_score,
          NTILE(5) OVER (ORDER BY monetary ASC) as m_score
      FROM cliente_stats
  )
  SELECT *,
      CASE
          WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN 'Champions'
          WHEN r_score >= 3 AND f_score >= 4 AND m_score >= 4 THEN 'Loyal Customers'
          WHEN r_score >= 4 AND f_score >= 3 AND m_score >= 3 THEN 'Potential Loyalists'
          WHEN r_score >= 4 AND f_score <= 2 AND m_score <= 2 THEN 'New Customers'
          WHEN r_score >= 3 AND f_score >= 3 AND m_score >= 3 THEN 'Promising'
          WHEN r_score <= 2 AND f_score >= 3 AND m_score >= 3 THEN 'At Risk'
          WHEN r_score <= 2 AND f_score <= 2 AND m_score >= 4 THEN 'Cannot Lose Them'
          WHEN r_score <= 2 AND f_score <= 2 AND m_score <= 2 THEN 'Lost'
          ELSE 'Others'
      END as segmento_rfm
  FROM rfm_scores;

  -- Vista de flujo de caja resumido
  CREATE OR REPLACE VIEW vista_flujo_caja_resumen AS
  SELECT
      DATE_TRUNC('month', fecha_movimiento) as periodo,
      cf.categoria,
      cf.tipo,
      SUM(fc.monto) as total_periodo,
      COUNT(*) as cantidad_movimientos
  FROM public.flujo_caja fc
  JOIN public.conceptos_flujo cf ON fc.concepto_id = cf.id
  WHERE fc.tipo = 'real'
  GROUP BY DATE_TRUNC('month', fecha_movimiento), cf.categoria, cf.tipo
  ORDER BY periodo DESC, cf.tipo, cf.categoria;

  6. Datos Iniciales

  -- =============================================
  -- DATOS INICIALES
  -- =============================================

  -- Conceptos de flujo de caja predeterminados
  INSERT INTO public.conceptos_flujo (nombre, tipo, categoria) VALUES
  ('Ventas en Efectivo', 'ingreso', 'ventas'),
  ('Ventas con Tarjeta', 'ingreso', 'ventas'),
  ('Cobro de Créditos', 'ingreso', 'ventas'),
  ('Compra de Mercadería', 'egreso', 'compras'),
  ('Pago a Proveedores', 'egreso', 'compras'),
  ('Alquiler', 'egreso', 'gastos_operativos'),
  ('Servicios Públicos', 'egreso', 'gastos_operativos'),
  ('Sueldos y Jornales', 'egreso', 'gastos_operativos'),
  ('Impuestos', 'egreso', 'impuestos'),
  ('Mantenimiento y Reparaciones', 'egreso', 'gastos_operativos');

  -- Segmentos predeterminados
  INSERT INTO public.segmentos_cliente (nombre, descripcion, criterios, color) VALUES
  ('Clientes VIP', 'Clientes con alto valor de compra', '{"total_compras": {"min": 100000},
  "frecuencia_compra": {"min": 2}}', '#FF6B6B'),
  ('Clientes Frecuentes', 'Clientes que compran regularmente', '{"frecuencia_compra": {"min": 1}}',
  '#4ECDC4'),
  ('Clientes Nuevos', 'Clientes registrados en los últimos 30 días', '{"dias_desde_registro": {"max": 30}}',     
   '#45B7D1'),
  ('Clientes Inactivos', 'Sin compras en los últimos 90 días', '{"dias_sin_compra": {"min": 90}}',
  '#96CEB4');

  📝 PASOS PARA APLICAR EN SUPABASE

  Paso 1: Backup

  -- Hacer backup antes de aplicar cambios
  pg_dump -h your-host -U your-user -d your-database > backup_before_upgrade.sql

  Paso 2: Aplicar en orden

  1. Ejecutar las nuevas tablas
  2. Aplicar modificaciones a tablas existentes
  3. Crear índices
  4. Crear funciones y triggers
  5. Crear vistas
  6. Insertar datos iniciales

  Paso 3: Verificar Permisos RLS

  -- Habilitar RLS en las nuevas tablas
  ALTER TABLE public.cotizaciones ENABLE ROW LEVEL SECURITY;
  ALTER TABLE public.servicios ENABLE ROW LEVEL SECURITY;
  ALTER TABLE public.cuenta_corriente ENABLE ROW LEVEL SECURITY;
  -- ... etc para todas las tablas nuevas

  -- Crear políticas RLS según tu configuración actual